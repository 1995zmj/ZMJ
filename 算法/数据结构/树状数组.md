# 树状数组

[参考](https://zhuanlan.zhihu.com/p/93795692)

`单点修改`和`区间求和`

它巧妙地利用了`二进制`，例如11，转化为二进制数就是$(1011)_2$，如果我们要求前11项和，可以分别查询$((0000)_2,(1000)_2]$，$((1000)_2,(1010)_2]$以及$((1010)_2,(1011)_2]$的和再相加。

这三个区间怎么来的呢？其实就是`不断地去掉二进制数最右边的一个1`的过程

更新，其实就是爬树的过场

二进制数$(100110)_2$，包含它的最小区间当然是$((100100)_2,(100110)_2]$，然后，它也肯定位于区间$((100000)_2,(101000)_2]$内。然后是$((100000)_2,(110000)_2]$，再然后是$((0)_2,(1000000)_2]$，不断地加二进制数最右边的一个1

## 二进制数最右边的一个1

```c
void lowbit(int x)
{
    return (x)&(-x)
}
```

-x相当于x按位取反再加1

$$原 => 1011$$
$$反 => 0100$$
$$补 => 0101$$

## 单点修改

```c
int tree[MAXN];
inline void update(int i, int x)
{
    for (int pos = i; pos < MAXN; pos += lowbit(pos))
        tree[pos] += x;
}
```

## 求前n项和

```c
inline int query(int n)
{
    int ans = 0;
    for (int pos = n; pos; pos -= lowbit(pos))
        ans += tree[pos];
    return ans;
}
```

## 区间查询

```c
inline int query(int a, int b)
{
    return query(b) - query(a - 1);
}
```